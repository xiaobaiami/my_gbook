> 进程的概念，如何管理进程，内核如何列举，创建进程，进程何时消亡。

## 3.1 进程
进程不仅是执行期的程序，还包含其他的资源，比如打开的文件，挂起的信号，处理器状态，内核数据，一个或多个线程等。
线程有计数器，进程栈，一组进程寄存器。是内核调度对象。Linux不区分进程线程。 </br>
通过调用 `fork()` 来创建新的进程，由 `clone()` 实现。 `exec()` 函数可以创建新的地址空间，并装载新的程序。
`exit()` 退出执行，释放资源，父进程通过 `wait4()` 来查询子进程是否终结，此时子进程处于僵死状态，直到父进程调用 `wait()` 或 `waitpid()`方法。

## 3.2 进程描述符及任务结构
所有进程组织为一个双向循环链表，称为任务队列。每一个节点表示一个进程，类型是 `task_struct`, 称为进程描述符。
包含了进程的所有信息。 </br>

通过slab分配器分配 `task_struct` 结构，可以达到对象复用和缓冲着色。在内核栈尾端有指针指向进程描述符，为了节省寄存器的数量。
</br>

每个进程有一个唯一的标识值 PID，这个值存放在进程描述符中。查找进程描述符非常重要，有的处理专门设定了寄存器存放这个值，
x86使用内存栈的栈尾的 `thread_info->task` 来进行定位。</br>

进程有5中状态
 - TASK_RUNNING  线程是可执行或者正在执行，唯一用户态可能的状态
 - TASK_INTERRUPTIBLE  睡眠，等待条件达成
 - TASK_UNINTERRUPTIBLE  接收信号也不会投入运行
 - _TASK_TRACED  被其他进程跟踪的进程
 - _TASK_STOPPED  停止执行 </br>
内核通过 `set_task_state(task, state)` 函数来调整进程的状态. </br>

程序在用户空间执行,当一个程序调用了系统调用或者触发某个异常,他就会陷入内核空间.我们称内核代表进程执行并处于进程上下文中.
在此上下文中current宏是有效的.</br>

Linux中的进程存在树状结构,PID为1的init进程是所有进程的起始,内核在系统启动的最后阶段启动init进程.
该进程执行初始化脚本和其他相关程序,最终完成启动.
每个进程有一个父进程的指针parent和子进程的链表:children.
`for_each_process(task)` 可以遍历整个任务队列.

## 3.3 进程创建
Unix通过 fork() 和 exec() 创建进程, fork通过拷贝当前进程来创建一个新的子进程,区别在于PID,PPID,某些资源和统计量不同/
exec负责读取可执行文件并将其载入地址空间运行.fork具有写实拷贝的优化,只有需要写入时才会复制数据,拥有各自的拷贝.</br>

fork() -> clone() -> do_fork() -> copy_process() </br>
copy_process()函数做的工作:
 1. 调用 dup_task_struct() 创建一个内核栈,thread_info结构和task_struct, 这些值和当前进程相同.
 2. 检查进程数目没有超出限制
 3. 清0一些进程描述符里的成员
 4. 子进程状态设为 TASK_UNINTERRUPTIBLE,确保不会运行
 5. 调用copy_flags()更新flags成员.清0超级用户权限标志,设置未调用exec()的标志
 6. 调用allc_pid()分配有效的PID
 7. 根据clone()的参数,拷贝或共享文件信息,信号处理函数,进程地址空间,命名空间.
 8. 扫尾工作,返回指针
 9. 有限运行子进程,因为子进程一般会马上调用exec()函数
 
## 3.4 线程的实现
通过共享资源来实现线程.和window系统差异巨大.创建线程的时候调用clone()需要传入一些参数标志指明需要共享的资源
 
## 3.5 进程终结
一般进程的析构是自身调用的.但当他接收到既不能处理也不能忽略的信号或异常时,进程可能被动的终结.该任务大部分要考do_exit()来完成.
 1. 将task_struct中的标志成员设为PF_EXITING
 2. 


